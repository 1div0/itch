import { IInstallResult } from "./core";
import * as sf from "../../os/sf";

import { Logger } from "../../logger";
import Context from "../../context";

import butler from "../../util/butler";

import { readReceipt, receiptHasFiles } from "./receipt";
import walkDir from "./walk-dir";

import { join, dirname, basename } from "path";

import { difference } from "underscore";

/**
 * An angel redemption is performed when we need to run arbitrary installers
 * that do not report which files they wrote.
 * 
 * Conceptually:
 *   - We rename the existing folder to a temporary folder
 *   - We install to a fresh folder
 *   - We merge angels with the fresh folder
 *   - We clean up the temporary folder
 * 
 * Angels are files that have been written by the game (like configurations
 * or save files) or the user (by applying a mod manually, for example)
 * They're not part of a fresh installation of the previous version,
 * but we do want to keep them around.
 * 
 * See also: bust-ghosts
 */
export default async function saveAngels<T extends IAngelSaviorOpts>(
  opts: T,
  f: (T) => Promise<IInstallResult>,
): Promise<ISwitcherooResult> {
  const { ctx, destPath } = opts;
  const logger = opts.logger.child({ name: "save-angels" });

  const receipt = await readReceipt(opts);
  let needSwitcheroo = true;

  if (!receiptHasFiles(receipt)) {
    // if we got no receipt, we have no idea which old files to
    // keep and which to clean up - so just to be on the safe side,
    // we don't remove any. no switcheroo here.
    logger.info(`No receipt found, will not perform a switcheroo`);
    needSwitcheroo = false;
  } else if (!await sf.exists(destPath)) {
    // there's no ephemerals to pass over
    logger.info(`Destination doesn't exist yet, will not perform a switcheroo`);
    needSwitcheroo = false;
  }

  if (!needSwitcheroo) {
    return await f(opts);
  }

  const previousPath = destPath + "-previous";
  await sf.rename(destPath, previousPath);

  await sf.mkdir(destPath);

  // this will contain *all* the previous files, including
  // files generated by a game, for example
  let allPreviousFiles = [];
  let walkPrevious = async () => {
    allPreviousFiles = await walkDir({ ctx, logger, destPath: previousPath });
  };

  try {
    // run the installer and walk the old directory in parallel
    await Promise.all([f(opts), walkPrevious()]);
    await f(opts);
  } catch (e) {
    logger.warn(`Installation failed, rolling back to previous version`);
    await sf.wipe(destPath);
    await sf.rename(previousPath, destPath);
    throw e;
  }

  // walk the freshly-installed dir now so we can store it in the
  // receipt later
  const newFiles = await walkDir(opts);

  // now, save angels if any
  const angels = difference(allPreviousFiles, receipt.files);
  if (angels.length > 0) {
    logger.info(
      `Saving ${angels.length} angels like: ${angels
        .slice(0, 4)
        .map(x => basename(x))
        .join(", ")}`,
    );
    await performAngelRedemption(opts, previousPath, angels);
  } else {
    logger.info("No angels to save");
  }

  await butler.wipe(previousPath, opts);

  return { files: newFiles };
}

async function performAngelRedemption(
  opts: IAngelSaviorOpts,
  previousPath: string,
  angels: string[],
) {
  const { destPath } = opts;

  // TODO: review this code, I'm not 100% confident
  // it's smart enough. Might warrant a butler command as well.
  for (const angel of angels) {
    const dark = join(previousPath, angel);
    const light = join(destPath, angel);

    await sf.mkdir(dirname(light));
    await sf.rename(dark, light);
  }
}

interface IAngelSaviorOpts {
  logger: Logger;
  ctx: Context;
  destPath: string;
}

interface ISwitcherooResult {
  files: string[];
}
